# Тема 8. Основы объектно-ориентированного программирования
Отчет по Теме #8 выполнил:
- Каримов Денис Азатович
- ПИЭ-23-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |
| Задание 6 | Отсутствует | Отсутствует |
| Задание 7 | Отсутствует | Отсутствует |
| Задание 8 | Отсутствует | Отсутствует |
| Задание 9 | Отсутствует | Отсутствует |
| Задание 10 | Отсутствует | Отсутствует |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- Т.В.Ротенштрайх

## Лабораторная работа №1
### Создайте класс “Car” с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями.
```python
# создаем класс Car (автомобиль).
class Car:
    
    # метод __init__ - это конструктор. он вызывается, когда создаем новую машину.
    # он принимает данные для производителя (make) и модели (model).
    def __init__(self, make, model):
        
        # записываем производителя в атрибут объекта.
        self.make = make 
        
        # записываем модель в атрибут объекта.
        self.model = model

# создаем объект 'my_car' (наш автомобиль) с конкретными данными.
my_car = Car("Toyota", "Corolla")
```
### Результат.
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/l1.PNG)

## Лабораторная работа №2
### Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
```python
# создаем класс Car (автомобиль).
class Car:
    
    # метод __init__ - это конструктор. он вызывается, когда создаем новую машину.
    # он принимает данные для производителя (make) и модели (model).
    def __init__(self, make, model):
        
        # записываем производителя в атрибут объекта.
        self.make = make 
        
        # записываем модель в атрибут объекта.
        self.model = model

    # добавляем новый метод drive (поехать).
    # он просто выводит сообщение, используя make и model нашей машины.
    def drive(self):
        print(f"Driving the {self.make} {self.model}")

# создаем объект 'my_car' (наш автомобиль) с конкретными данными.
my_car = Car("Toyota", "Corolla")

# вызываем метод drive, чтобы заставить машину "поехать".
my_car.drive()
```
### Результат.
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/l2.PNG)

## Лабораторная работа №3
### Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
```python
# создаем класс Car (автомобиль) из предыдущих заданий.
class Car:
    
    # конструктор.
    def __init__(self, make, model):
        self.make = make 
        self.model = model

    # метод "поехать".
    def drive(self):
        print(f"Driving the {self.make} {self.model}")

# создаем класс ElectricCar, который наследуется от Car.
# это значит, что ElectricCar получит все методы и атрибуты класса Car.
class ElectricCar(Car): 
    
    # конструктор для электромобиля. добавляем новый параметр battery_capacity.
    def __init__(self, make, model, battery_capacity):
        
        # вызываем конструктор родительского класса (Car) через super().
        # это нужно, чтобы инициализировать make и model.
        super().__init__(make, model)
        
        # записываем емкость батареи, это собственный атрибут ElectricCar.
        self.battery_capacity = battery_capacity 

    # новый метод charge (заряжаться).
    def charge(self):
        # выводим сообщение о зарядке, используя все атрибуты.
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh battery.")

# создаем объект 'my_electric_car', теперь это Tesla Model S.
my_electric_car = ElectricCar("Tesla", "Model S", 75)

# заставляем машину "поехать" (используем унаследованный метод).
my_electric_car.drive()

# заставляем машину "заряжаться" (используем собственный метод).
my_electric_car.charge()
```
### Результат.
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/l3.PNG)

## Лабораторная работа №4
### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
```python
# создаем класс Car (автомобиль).
class Car:
    
    # конструктор.
    def __init__(self, make, model):
        
        # защищенный атрибут (одно подчеркивание). доступен, но не рекомендуется менять.
        self._make = make 
        
        # приватный атрибут (два подчеркивания). Python меняет его имя, чтобы ограничить доступ.
        self.__model = model 

    # метод drive (поехать).
    # внутри класса доступ к защищенным и приватным атрибутам разрешен.
    def drive(self):
        print(f"Driving the {self._make} {self.__model}")

# создаем объект 'my_car'.
my_car = Car("Toyota", "Corolla")

# выводим защищенный атрибут. 
# это сработает, но IDE предупредит, что так делать не надо (Convention - соглашение).
print(my_car._make)

# попытка вывести приватный атрибут напрямую через __model вызовет ошибку (AttributeError).
# print(my_car.__model) # эта строка не должна выполняться!

# заставляем машину "поехать" (метод drive).
my_car.drive()
```
### Результат.
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/l4.PNG)

## Лабораторная работа №5
### Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.
```python
# создаем класс Shape (фигура) - это базовый класс для полиморфизма.
class Shape:
    
    # определяем метод area (площадь), который будет переопределен.
    # пока он пустой (pass).
    def area(self):
        pass

# создаем класс Rectangle (прямоугольник), наследуем его от Shape.
class Rectangle(Shape):
    
    # конструктор для прямоугольника, принимает ширину (width) и высоту (height).
    def __init__(self, width, height):
        self.width = width
        self.height = height

    # переопределяем метод area() для расчета площади прямоугольника.
    def area(self):
        return self.width * self.height

# создаем класс Circle (круг), наследуем его от Shape.
class Circle(Shape):
    
    # конструктор для круга, принимает радиус (radius).
    def __init__(self, radius):
        self.radius = radius

    # переопределяем метод area() для расчета площади круга.
    # используем 3.14 как приближенное значение Пи.
    def area(self):
        return 3.14 * self.radius * self.radius

# создаем объекты разных классов, но они все являются "фигурами" (Shape).
rectangle = Rectangle(width=10, height=5)
circle = Circle(radius=7)

# создаем массив (список) и помещаем туда фигуры.
shapes = [rectangle, circle]
...
print("Расчет площади фигур")

# с помощью цикла обходим массив.
# здесь проявляется полиморфизм: для каждой фигуры вызывается свой метод area().
for shape in shapes:
    # у прямоугольника вызовется Rectangle.area(), у круга - Circle.area().
    print(f"Площадь {shape.__class__.__name__}: {shape.area()}")
```
### Результат.
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/l5.PNG)

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
```python
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author

    def info(self):
        return f"Книга: {self.title}, Автор: {self.author}"

book1 = Book("Мастер и Маргарита", "М. Булгаков")
print(book1.info())

```
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/s1.PNG)
### В ходе выполнения программы был создан класс Book с атрибутами title и author, а также методом info(), который возвращает информацию о книге. После создания объекта book1 программа корректно вывела данные о названии и авторе книги.

## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
```python
class Book:
    def __init__(self, title, author, year):
        self.title = title
        self.author = author
        self.year = year
        self.is_read = False

    def mark_as_read(self):
        self.is_read = True

    def info(self):
        status = "прочитана" if self.is_read else "не прочитана"
        return f"{self.title} ({self.year}) - {self.author}. Статус: {status}"

book2 = Book("Преступление и наказание", "Ф. Достоевский", 1866)
print(book2.info())
book2.mark_as_read()
print(book2.info())
```
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/s2.PNG)
### Был доработан класс Book, добавлены новые атрибуты (year, is_read) и методы (mark_as_read). После вызова метода статус книги изменился с не прочитана на прочитана, что подтверждает корректную работу атрибутов и методов.

## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
```python
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author

class EBook(Book):
    def __init__(self, title, author, file_size):
        super().__init__(title, author)
        self.file_size = file_size

    def info(self):
        return f"Электронная книга: {self.title} - {self.author}, размер файла: {self.file_size} МБ"

ebook = EBook("1984", "Джордж Оруэлл", 2.5)
print(ebook.info())
```
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/s3.PNG)
### Было реализовано наследование: создан подкласс EBook, наследующий базовый класс Book. Подкласс получил дополнительный атрибут file_size и собственный метод info(). Программа успешно продемонстрировала вывод информации о электронной книге.

## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
```python
class Book:
    def __init__(self, title, author):
        self.__title = title
        self.__author = author

    def get_info(self):
        return f"{self.__title} - {self.__author}"

    def set_title(self, new_title):
        self.__title = new_title

book = Book("Тихий Дон", "М. Шолохов")
print(book.get_info())
book.set_title("Поднятая целина")
print(book.get_info())
```
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/s4.PNG)
### В программе реализована инкапсуляция — атрибуты класса __title и __author сделаны приватными. Доступ к ним осуществляется через методы get_info() и set_title(). Изменение названия книги через сеттер подтвердило работу инкапсуляции.

## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
```python
class Reader:
    def describe(self):
        return "Я читаю книги."

class Student(Reader):
    def describe(self):
        return "Я читаю учебники."

class Professor(Reader):
    def describe(self):
        return "Я читаю научные статьи."

people = [Reader(), Student(), Professor()]
for person in people:
    print(person.describe())
```
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/pic/s5.PNG)
### Реализован полиморфизм через переопределение метода describe() в классах Reader, Student и Professor. При вызове метода для разных объектов программа вывела уникальные фразы, подтверждая корректную работу механизма полиморфизма.

## Общие выводы по теме
### В ходе выполнения лабораторных и самостоятельных работ по Теме 8 «Основы объектно-ориентированного программирования» были изучены и закреплены основные понятия объектно-ориентированного программирования: создание классов и объектов, использование атрибутов и методов, а также реализация принципов наследования, инкапсуляции и полиморфизма.
### Лабораторные работы: Осваивались базовые принципы построения классов и объектов, добавление и использование методов, наследование свойств базового класса, создание защищённых и приватных атрибутов, переопределение методов в дочерних классах и демонстрация полиморфизма при работе с различными типами объектов.
### Самостоятельные работы: Применялись полученные знания на практике — создание собственных классов и объектов, добавление новых атрибутов и методов, реализация наследования с использованием super(), защита данных с помощью инкапсуляции, а также демонстрация полиморфного поведения в пользовательских примерах.
