# Тема 9. ООП на Python: концепции, принципы и примеры реализации
Отчет по Теме #9 выполнил:
- Каримов Денис Азатович
- ПИЭ-23-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | Отсутствует |
| Задание 3 | + | Отсутствует |
| Задание 4 | + | Отсутствует |
| Задание 5 | + | Отсутствует |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- Т.В.Ротенштрайх

## Лабораторная работа №1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.
```python
class Ivan:
    __slots__ = ['name']

    def __init__(self, name):
        if name == 'Иван':
            self.name = f"Да, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"

person1 = Ivan('Алексей')
person2 = Ivan('Иван')

print(person1.name)
print(person2.name)

person2.surname = 'Петров'
```
### Результат.
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/l1.PNG)

## Лабораторная работа №2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.
```python
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def composition(self):
        if self.ingredient:
            print(f"Мороженое с {self.ingredient}")
        else:
            print("Обычное мороженое")

icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```
### Результат.
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/l2.PNG)

## Лабораторная работа №3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу...что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу...что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.
```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):
        self._value = value

    def get_value(self):
        return self._value

    def del_value(self):
        del self._value

    value = property(get_value, set_value, del_value, "Свойство value")


obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```
### Результат.
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/l3.PNG)

## Лабораторная работа №4
### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.
```python
class Mammal:
    className = 'Mammal'

class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'

class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'

dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")
```
### Результат.
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/l4.PNG)

## Лабораторная работа №5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.
```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")

class English:
    @staticmethod
    def greeting():
        print("Hello")

def greet(language):
    language.greeting()

ivan = Russian()
greet(ivan)
john = English()
greet(john)
```
### Результат.
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/l5.PNG)

## Самостоятельная работа №1
## Классовая структура:

Есть **Помидор** со следующими характеристиками:
* Индекс
* Стадия созревания (стадии: отсутствует, цветение, зеленый, красный)

**Помидор** может:
* Расти (переходить на следующую стадию созревания)
* Предоставлять информацию о своей зрелости

Есть **Куст с помидорами**, который:
* Содержит список томатов, которые на нем растут

А также может:
* Расти вместе с томатами
* Предоставлять информацию о зрелости всех томатов
* Предоставлять урожай

И также есть **Садовник**, который имеет:
* Имя
* Растение, за которым он ухаживает

Он может:
* Ухаживать за растением
* Собирать с него урожай

## Задание:

### Класс `Tomato`:
1) Создайте класс **`Tomato`**
2) Создайте статическое свойство **`states`**, которое будет содержать все стадии созревания помидора
3) Создайте метод `__init__`, внутри которого будут определены два динамических свойства: `_index` (передается параметром) и `_state` (принимает первое значение из словаря `states`). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
4) Создайте метод **`grow()`**, который будет переводить томат на следующую стадию созревания
5) Создайте метод **`is_ripe()`**, который будет проверять, что томат созрел

### Класс `TomatoBush`:
1) Создайте класс **`TomatoBush`**
2) Определите метод `__init__`, который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса **`Tomato`**. Данный список будет храниться внутри динамического свойства **`tomatoes`**
3) Создайте метод **`grow_all()`**, который будет переводить все объекты из списка томатов на следующий этап созревания
4) Создайте метод **`all_are_ripe()`**, который будет возвращать **`True`**, если все томаты из списка стали спелыми.
5) Создайте метод **`give_away_all()`**, который будет чистить список томатов после сбора урожая

### Класс `Gardener`:
1) Создайте класс **`Gardener`**
2) Создайте метод `__init__`, внутри которого будут определены два динамических свойства: **`name`** (передается параметром, является публичным) и **`_plant`** (принимает объект класса **`TomatoBush`**). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3) Создайте метод **`work()`**, который заставляет садовника работать, что позволяет растению становиться более зрелым
4) Создайте метод **`harvest()`**, который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5) Создайте статический метод **`knowledge_base()`**, который выведет в консоль справку по садоводству

## Тесты:
1) Вызовите справку по садоводству
2) Создайте объекты классов **`TomatoBush`** и **`Gardener`**
3) Используя объект класса **`Gardener`**, поухаживайте за кустом с помидорами
4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними
5) Соберите урожай
```python
# класс Tomato (помидор)
class Tomato:
    # статическое свойство, описывающее все стадии созревания помидора
    states = ['отсутствует', 'цветение', 'зелёный', 'красный']

    # конструктор класса
    def __init__(self, index):
        # динамическое свойство index - индекс помидора на кусте
        self.index = index
        # динамическое свойство state - текущая стадия созревания
        self.state = Tomato.states[0]

    # метод grow переводит томат на следующую стадию созревания
    def grow(self):
        if self.state != Tomato.states[-1]:
            next_index = Tomato.states.index(self.state) + 1
            self.state = Tomato.states[next_index]

    # метод is_ripe проверяет, что томат созрел (достиг стадии 'красный')
    def is_ripe(self):
        return self.state == Tomato.states[-1]


# класс TomatoBush (куст помидоров)
class TomatoBush:
    # конструктор класса
    def __init__(self, count):
        # динамическое свойство tomatoes - список объектов Tomato
        self.tomatoes = [Tomato(index) for index in range(1, count+1)]

    # метод grow_all переводит все томаты на следующую стадию созревания
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()

    # метод all_are_ripe проверяет, все ли томаты созрели
    def all_are_ripe(self):
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    # метод give_away_all очищает список томатов после сбора урожая
    def give_away_all(self):
        self.tomatoes = []


# класс Gardener (садовник)
class Gardener:
    # конструктор класса
    def __init__(self, name, plant):
        # динамическое свойство name - имя садовника, публичное
        self.name = name
        # динамическое свойство _plant - объект растения (куст), защищённое
        self._plant = plant

    # метод work позволяет садовнику ухаживать за растением
    def work(self):
        print(f"{self.name} ухаживает за растением...")
        self._plant.grow_all()
        print("растение стало более зрелым.")

    # метод harvest проверяет зрелость плодов и собирает урожай
    def harvest(self):
        if self._plant.all_are_ripe():
            print(f"{self.name} собирает урожай!")
            self._plant.give_away_all()
        else:
            print("помидоры ещё не созрели. ухаживайте за ними дальше.")

    # статический метод knowledge_base выводит справку по садоводству
    @staticmethod
    def knowledge_base():
        print("справка по садоводству: ухаживайте за растениями регулярно, чтобы они созрели.")

# вызов справки по садоводству
Gardener.knowledge_base()

# создание объекта класса TomatoBush с 3 помидорами
bush = TomatoBush(3)

# создание садовника, который ухаживает за этим кустом
gardener = Gardener("Иван", bush)

# первый уход за кустом
gardener.work()

# попытка собрать урожай до созревания
gardener.harvest()

# второй уход за кустом
gardener.work()
gardener.work()

# попытка собрать урожай после созревания
gardener.harvest()
```
![Меню](https://github.com/vomiraq/eduSOFTENG/blob/%D0%A2%D0%B5%D0%BC%D0%B0_9/pic/s.PNG)
### Был создан класс Tomato с динамическими свойствами _index и _state, класс TomatoBush управляет списком томатов и их созреванием, класс Gardener умеет ухаживать за растением и собирать урожай, программа демонстрирует работу садовника: уход за растениями, проверку зрелости и сбор урожая.

## Общие выводы по теме
## ВЫВОД
### В ходе выполнения лабораторной и самостоятельной работы по Теме 9 «ООП на Python: концепции, принципы и примеры реализации» были изучены и закреплены ключевые понятия объектно-ориентированного программирования: создание классов и объектов, использование атрибутов и методов, а также реализация принципов наследования, инкапсуляции и полиморфизма.
### Лабораторные работы: Осваивались базовые принципы построения классов и объектов, добавление и использование методов, работа с защищёнными и приватными атрибутами, демонстрация наследования и полиморфизма при взаимодействии разных объектов.
### Самостоятельная работа: Применялись полученные знания на практике — создание собственного класса томата с динамическими свойствами, управление стадиями созревания, создание куста и садовника, работа с методами роста и сбора урожая, использование статического метода для справки по садоводству, закрепление принципов инкапсуляции и взаимодействия объектов.

